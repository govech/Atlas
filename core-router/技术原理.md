# Android路由框架原理总览

## 📚 原理文档导航

本路由框架的技术原理分为以下几个部分，建议按顺序阅读：

1. **[核心架构原理](ARCHITECTURE_PRINCIPLES.md)** - 整体架构设计和核心组件
2. **[拦截器系统原理](INTERCEPTOR_PRINCIPLES.md)** - 责任链模式和拦截器机制
3. **[注解处理原理](ANNOTATION_PRINCIPLES.md)** - 注解扫描和路由注册机制
4. **[参数传递原理](PARAMETER_PRINCIPLES.md)** - Bundle处理和类型安全参数传递
5. **[异步处理和依赖注入原理](ASYNC_DI_PRINCIPLES.md)** - 协程异步和Hilt集成

## 🏗️ 整体架构概览

```
┌─────────────────────────────────────────────────────────────┐
│                        应用层                                │
│  Router.with(context).to("/profile").withString().go()     │
└─────────────────────────┬───────────────────────────────────┘
                          │
┌─────────────────────────▼───────────────────────────────────┐
│                      框架层                                  │
│                                                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │   Router    │  │ RouteRequest│  │ NavigationCallback  │  │
│  │   (入口)    │  │  (请求对象) │  │   (回调处理)        │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
│                                                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │ RouteTable  │  │Interceptor  │  │AnnotationProcessor │  │
│  │ (路由表)    │  │ Manager     │  │  (注解处理器)       │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
│                                                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │BundleBuilder│  │CallbackHandler│ │ RouteResultManager │  │
│  │ (参数构建)  │  │ (回调处理)   │  │   (结果管理)        │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────┬───────────────────────────────────┘
                          │
┌─────────────────────────▼───────────────────────────────────┐
│                    Android系统层                             │
│  Intent + Bundle + startActivity + ActivityResult          │
└─────────────────────────────────────────────────────────────┘
```

## 🔄 完整导航流程

```
用户调用
Router.with(context).to("/profile").withString("userId", "123").go()
                    │
                    ▼
            创建RouteRequest对象
            - context: Context
            - path: "/profile"  
            - bundle: Bundle{userId="123"}
                    │
                    ▼
         AnnotationProcessor扫描注册
         "/profile" -> ProfileActivity.class
                    │
                    ▼
            InterceptorManager执行拦截器链
            ┌─────────────────────────────────┐
            │ LogInterceptor (priority: 1000) │ ──┐
            │ LoginInterceptor (priority: 800)│   │ 按优先级
            │ PermissionInterceptor (priority:│   │ 顺序执行
            │ 600)                            │ ──┘
            └─────────────────────────────────┘
                    │
            ┌───────┴───────┐
            │               │
        拦截器返回true    拦截器返回false
            │               │
            ▼               ▼
        继续导航          中断导航
            │           调用onError回调
            ▼
        RouteTable查找Activity类
        "/profile" -> ProfileActivity.class
            │
            ▼
        构建Intent对象
        Intent(context, ProfileActivity.class)
        intent.putExtras(bundle)
            │
            ▼
        执行startActivity()
            │
            ▼
        CallbackHandler执行成功回调
        callback.onSuccess("/profile")
```

## 🧩 核心设计模式

### 1. 建造者模式 (Builder Pattern)
```kotlin
Router.with(context)          // 创建建造者
    .to("/profile")           // 设置路径
    .withString("id", "123")  // 添加参数
    .withCallback(callback)   // 设置回调
    .go()                     // 执行构建
```

### 2. 责任链模式 (Chain of Responsibility)
```kotlin
// 拦截器链按优先级顺序执行
LogInterceptor -> LoginInterceptor -> PermissionInterceptor -> 导航执行
```

### 3. 观察者模式 (Observer Pattern)
```kotlin
// 导航回调通知
interface NavigationCallback {
    fun onSuccess(path: String)
    fun onError(exception: Exception)
}
```

### 4. 单例模式 (Singleton Pattern)
```kotlin
// 通过Hilt实现的单例组件
@Singleton
class Router @Inject constructor(...)
```

### 5. 工厂模式 (Factory Pattern)
```kotlin
// RouterModule作为工厂创建各种组件
@Provides
@Singleton
fun provideRouter(...): Router = Router(...)
```

## ⚡ 性能优化策略

### 1. 路由表缓存
- 使用ConcurrentHashMap存储路径映射
- 避免重复的注解扫描
- 支持增量注册

### 2. 拦截器优化
- 按优先级排序，高优先级先执行
- 支持异步拦截器，不阻塞主线程
- 拦截器结果缓存

### 3. 参数传递优化
- Bundle对象池复用
- 大参数压缩传输
- 类型安全的编译时检查

### 4. 异步处理优化
- 协程池管理
- 主线程和IO线程合理分工
- 回调自动清理防止内存泄漏

### 5. 依赖注入优化
- 单例模式减少对象创建
- 懒加载非核心组件
- 生命周期自动管理

## 🔒 线程安全保证

### 1. 路由表线程安全
```kotlin
class RouteTable {
    // 使用线程安全的ConcurrentHashMap
    private val routes = ConcurrentHashMap<String, Class<out Activity>>()
}
```

### 2. 拦截器管理线程安全
```kotlin
class InterceptorManager {
    // 全局拦截器使用同步块保护
    private val globalInterceptors = mutableListOf<RouteInterceptor>()
    
    fun addGlobalInterceptor(interceptor: RouteInterceptor) {
        synchronized(globalInterceptors) {
            globalInterceptors.add(interceptor)
            globalInterceptors.sortBy { it.priority }
        }
    }
}
```

### 3. 回调处理线程安全
```kotlin
class CallbackHandler {
    // 使用主线程Handler确保回调在主线程执行
    private val mainHandler = Handler(Looper.getMainLooper())
}
```

## 🛡️ 异常处理机制

### 1. 异常类型层次
```kotlin
sealed class RouteException(message: String, cause: Throwable? = null) : Exception(message, cause) {
    class PathNotFoundException(path: String) : RouteException("路径未找到: $path")
    class ActivityNotFoundException(path: String) : RouteException("Activity未找到: $path")
    class InvalidPathException(path: String) : RouteException("无效路径: $path")
    class PathConflictException(message: String) : RouteException(message)
    class InterceptedException(path: String) : RouteException("导航被拦截: $path")
    class NavigationException(message: String, cause: Throwable? = null) : RouteException(message, cause)
}
```

### 2. 降级处理
```kotlin
class FallbackHandler {
    fun handleNavigationFailure(request: RouteRequest, exception: Exception) {
        when (exception) {
            is RouteException.PathNotFoundException -> {
                // 跳转到404页面
                navigateToNotFoundPage(request.context)
            }
            is RouteException.InterceptedException -> {
                // 跳转到登录页面
                navigateToLoginPage(request.context, request.path)
            }
            else -> {
                // 显示通用错误提示
                showErrorDialog(request.context, exception.message)
            }
        }
    }
}
```

## 📊 监控和调试

### 1. 日志系统
```kotlin
class LogInterceptor : RouteInterceptor {
    override suspend fun intercept(request: RouteRequest): Boolean {
        val startTime = System.currentTimeMillis()
        
        LogUtil.d("Router", """
            导航开始:
            路径: ${request.path}
            参数: ${request.bundle.keySet().joinToString(", ")}
            上下文: ${request.context::class.simpleName}
        """.trimIndent())
        
        return true
    }
}
```

### 2. 性能监控
```kotlin
class PerformanceMonitor {
    fun trackNavigation(path: String, duration: Long, success: Boolean) {
        Analytics.track("route_navigation", mapOf(
            "path" to path,
            "duration" to duration,
            "success" to success,
            "timestamp" to System.currentTimeMillis()
        ))
    }
}
```

### 3. 路由统计
```kotlin
class RouteStatistics {
    private val navigationCounts = ConcurrentHashMap<String, AtomicInteger>()
    private val errorCounts = ConcurrentHashMap<String, AtomicInteger>()
    
    fun recordNavigation(path: String) {
        navigationCounts.getOrPut(path) { AtomicInteger(0) }.incrementAndGet()
    }
    
    fun recordError(path: String) {
        errorCounts.getOrPut(path) { AtomicInteger(0) }.incrementAndGet()
    }
    
    fun getStatistics(): Map<String, NavigationStats> {
        return navigationCounts.mapValues { (path, count) ->
            NavigationStats(
                path = path,
                totalNavigations = count.get(),
                errorCount = errorCounts[path]?.get() ?: 0
            )
        }
    }
}
```

## 🔧 扩展点

### 1. 自定义拦截器
```kotlin
class CustomInterceptor : RouteInterceptor {
    override val priority: Int = 500
    override suspend fun intercept(request: RouteRequest): Boolean {
        // 自定义拦截逻辑
        return true
    }
}
```

### 2. 自定义参数处理
```kotlin
class CustomRouteRequest : RouteRequest {
    fun withCustomObject(key: String, obj: CustomObject): RouteRequest {
        // 自定义对象序列化
        val json = CustomSerializer.serialize(obj)
        return withString(key, json)
    }
}
```

### 3. 自定义导航策略
```kotlin
class CustomNavigationStrategy : NavigationStrategy {
    override fun navigate(context: Context, intent: Intent): Boolean {
        // 自定义导航逻辑，如Fragment导航
        return true
    }
}
```

## 📈 框架优势总结

1. **简单易用**: 链式调用API，学习成本低
2. **功能强大**: 支持拦截器、回调、异步等高级功能
3. **类型安全**: 编译时类型检查，减少运行时错误
4. **高性能**: 优化的数据结构和算法，导航耗时<100ms
5. **可扩展**: 支持自定义拦截器、参数处理等扩展
6. **线程安全**: 全面的线程安全保证
7. **内存安全**: 防止内存泄漏的设计
8. **易调试**: 完善的日志和监控系统
9. **兼容性好**: 支持Android API 24+
10. **集成简单**: 与Hilt无缝集成

这个路由框架通过精心的架构设计和实现，为Android应用提供了一套完整、高效、易用的页面导航解决方案。