# Atlas Android Framework 编码规范文档

## 1. 概述

本文档定义了Atlas Android Framework项目的编码规范，旨在保持代码风格的一致性，提高代码质量和可维护性。所有开发人员必须遵守本规范。

### 1.1 规范原则

- **一致性**：保持代码风格统一
- **可读性**：代码易于理解和维护
- **简洁性**：避免冗余和复杂的代码
- **安全性**：遵循安全最佳实践
- **性能**：考虑代码执行效率

### 1.2 适用范围

本规范适用于Atlas项目的所有Kotlin/Java代码、XML资源文件、Gradle构建脚本等。

## 2. 命名规范

### 2.1 包名

- 全部小写，使用反向域名
- 单词之间不使用分隔符
- 避免使用下划线或连字符

```kotlin
// ✅ 正确
package com.sword.atlas.core.network

// ❌ 错误
package com.sword.Atlas.core_network
package com.sword.atlas.core-network
```

### 2.2 类名

- 使用 PascalCase（大驼峰命名法）
- 名词或名词短语
- 清晰表达类的职责

```kotlin
// ✅ 正确
class UserRepository
class LoginViewModel
class NetworkInterceptor
class BaseActivity

// ❌ 错误
class userRepository
class login_view_model
class Interceptor  // 太泛化
```

**特殊类型命名：**

| 类型 | 命名规则 | 示例 |
|------|---------|------|
| Activity | XxxActivity | LoginActivity, MainActivity |
| Fragment | XxxFragment | UserListFragment, HomeFragment |
| ViewModel | XxxViewModel | UserViewModel, LoginViewModel |
| Adapter | XxxAdapter | UserListAdapter, MultiTypeAdapter |
| Repository | XxxRepository | UserRepository, LoginRepository |
| Dialog | XxxDialog | CommonDialog, LoadingDialog |
| Util | XxxUtil | DateUtil, NetworkUtil |
| Manager | XxxManager | DownloadManager, CacheManager |
| Interface | 不加I前缀 | UserApi, OnClickListener |

### 2.3 方法名

- 使用 camelCase（小驼峰命名法）
- 动词或动词短语
- 清晰表达方法的行为

```kotlin
// ✅ 正确
fun loadUserData()
fun getUserById(id: Long)
fun isNetworkAvailable(): Boolean
fun onCreate()

// ❌ 错误
fun LoadUserData()
fun get_user_by_id(id: Long)
fun networkAvailable(): Boolean
```

**常用方法命名模式：**

| 模式 | 说明 | 示例 |
|------|------|------|
| get/set | 获取/设置属性 | getUserName(), setUserName() |
| is/has | 布尔判断 | isValid(), hasPermission() |
| load/fetch | 加载数据 | loadUserList(), fetchData() |
| save/update | 保存/更新 | saveUser(), updateProfile() |
| show/hide | 显示/隐藏 | showLoading(), hideDialog() |
| init/setup | 初始化 | initView(), setupRecyclerView() |
| on | 事件回调 | onClick(), onDataLoaded() |

### 2.4 变量名

- 使用 camelCase（小驼峰命名法）
- 名词或名词短语
- 有意义的名称，避免单字母（除循环变量）

```kotlin
// ✅ 正确
val userName: String
val userList: List<User>
var isLoading: Boolean
private val _userState = MutableStateFlow<UiState<User>>(UiState.Idle)

// ❌ 错误
val UserName: String
val list: List<User>  // 太泛化
var loading: Boolean  // 应该用is前缀
val a = "test"  // 无意义
```

**特殊变量命名：**

```kotlin
// StateFlow/LiveData - 私有可变，公开不可变
private val _userState = MutableStateFlow<User?>(null)
val userState: StateFlow<User?> = _userState.asStateFlow()

// ViewBinding
private lateinit var binding: ActivityMainBinding

// 集合
val userList: List<User>  // 不要用users
val userMap: Map<Long, User>
val userSet: Set<User>

// 布尔值
val isVisible: Boolean
val hasData: Boolean
val canEdit: Boolean
```

### 2.5 常量名

- 使用 UPPER_SNAKE_CASE（全大写下划线分隔）
- 定义在 companion object 或 object 中

```kotlin
// ✅ 正确
companion object {
    const val MAX_RETRY_COUNT = 3
    const val DEFAULT_TIMEOUT = 30_000L
    const val BASE_URL = "https://api.example.com"
}

object AppConstants {
    const val DATABASE_NAME = "atlas_database"
    const val SHARED_PREFS_NAME = "app_prefs"
}

// ❌ 错误
const val maxRetryCount = 3
const val Max_Retry_Count = 3
val BASE_URL = "https://api.example.com"  // 应该用const
```

### 2.6 资源文件命名

使用 snake_case（小写下划线分隔）

**布局文件：**

| 类型 | 命名规则 | 示例 |
|------|---------|------|
| Activity | activity_xxx.xml | activity_main.xml, activity_login.xml |
| Fragment | fragment_xxx.xml | fragment_user_list.xml |
| Dialog | dialog_xxx.xml | dialog_common.xml |
| Item | item_xxx.xml | item_user.xml, item_message.xml |
| Layout | layout_xxx.xml | layout_title_bar.xml |

**Drawable文件：**

| 类型 | 命名规则 | 示例 |
|------|---------|------|
| Icon | ic_xxx.xml | ic_home.xml, ic_back.xml |
| Background | bg_xxx.xml | bg_button.xml, bg_card.xml |
| Shape | shape_xxx.xml | shape_circle.xml |
| Selector | selector_xxx.xml | selector_button.xml |

**其他资源：**

```xml
<!-- strings.xml -->
<string name="app_name">Atlas</string>
<string name="login_title">登录</string>
<string name="error_network">网络错误</string>

<!-- colors.xml -->
<color name="primary">#6200EE</color>
<color name="text_primary">#212121</color>

<!-- dimens.xml -->
<dimen name="text_size_large">18sp</dimen>
<dimen name="margin_normal">16dp</dimen>

<!-- ids -->
android:id="@+id/tv_user_name"
android:id="@+id/btn_submit"
android:id="@+id/rv_user_list"
```

## 3. 代码风格

### 3.1 缩进和空格

- 使用 4 个空格缩进，不使用 Tab
- 操作符两侧加空格
- 逗号后加空格
- 冒号前不加空格，后加空格（类型声明除外）

```kotlin
// ✅ 正确
val sum = a + b
val list = listOf(1, 2, 3)
fun getUserById(id: Long): User

// ❌ 错误
val sum=a+b
val list = listOf(1,2,3)
fun getUserById(id : Long) : User
```

### 3.2 行长度

- 每行最多 120 个字符
- 超过时合理换行

```kotlin
// ✅ 正确
val user = User(
    id = 1L,
    name = "张三",
    email = "zhangsan@example.com",
    phone = "13800138000"
)

// 链式调用换行
userList
    .filter { it.age > 18 }
    .map { it.name }
    .sortedBy { it }

// ❌ 错误
val user = User(id = 1L, name = "张三", email = "zhangsan@example.com", phone = "13800138000", address = "北京市朝阳区")
```

### 3.3 空行

- 类成员之间加空行
- 逻辑块之间加空行
- 不要有多余的空行

```kotlin
// ✅ 正确
class UserViewModel @Inject constructor(
    private val repository: UserRepository
) : BaseViewModel() {

    private val _userState = MutableStateFlow<UiState<User>>(UiState.Idle)
    val userState: StateFlow<UiState<User>> = _userState.asStateFlow()

    fun loadUser(userId: Long) {
        viewModelScope.launch {
            _userState.value = UiState.Loading
            
            when (val result = repository.getUser(userId)) {
                is DataResult.Success -> {
                    _userState.value = UiState.Success(result.data)
                }
                is DataResult.Error -> {
                    _userState.value = UiState.Error(result.code, result.message)
                }
            }
        }
    }
}
```

### 3.4 大括号

- 左大括号不换行
- 右大括号单独一行
- 单行语句也要使用大括号

```kotlin
// ✅ 正确
if (condition) {
    doSomething()
}

when (state) {
    is UiState.Loading -> {
        showLoading()
    }
    is UiState.Success -> {
        hideLoading()
    }
}

// ❌ 错误
if (condition)
{
    doSomething()
}

if (condition) doSomething()  // 单行也要加大括号
```

### 3.5 导入语句

- 按字母顺序排列
- 不使用通配符导入（*）
- 移除未使用的导入

```kotlin
// ✅ 正确
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import com.sword.atlas.core.common.ext.toast
import com.sword.atlas.databinding.ActivityMainBinding

// ❌ 错误
import com.sword.atlas.core.common.ext.*
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
```


## 4. 注释要求

### 4.1 文件头注释

每个文件应包含简要说明（可选，但推荐用于复杂类）

```kotlin
/**
 * 用户仓库，负责用户数据的获取和缓存
 * 
 * @author Atlas Team
 * @since 1.0.0
 */
class UserRepository @Inject constructor(
    private val api: UserApi,
    private val userDao: UserDao
) : BaseRepository()
```

### 4.2 类注释

- 公开类必须有 KDoc 注释
- 说明类的职责和用途
- 必要时说明使用示例

```kotlin
/**
 * 用户列表ViewModel
 * 
 * 负责管理用户列表的加载、刷新和分页
 * 
 * 使用示例：
 * ```
 * viewModel.loadUserList()
 * viewModel.userListState.collect { state ->
 *     when (state) {
 *         is UiState.Success -> showData(state.data)
 *         is UiState.Error -> showError(state.message)
 *     }
 * }
 * ```
 */
@HiltViewModel
class UserListViewModel @Inject constructor(
    private val repository: UserRepository
) : BaseViewModel()
```

### 4.3 方法注释

- 公开方法必须有 KDoc 注释
- 说明方法的功能、参数、返回值
- 复杂逻辑需要详细说明

```kotlin
/**
 * 加载用户信息
 * 
 * 优先从本地数据库获取，如果不存在则从网络获取并缓存
 * 
 * @param userId 用户ID
 * @return 用户信息结果，成功返回User对象，失败返回错误信息
 */
suspend fun getUser(userId: Long): Result<User> {
    // 先从数据库获取
    val localUser = userDao.getUserById(userId).first()
    if (localUser != null) {
        return Result.Success(localUser.toUser())
    }
    
    // 从网络获取
    return executeRequest {
        api.getUser(userId)
    }
}
```

### 4.4 行内注释

- 解释复杂的业务逻辑
- 说明特殊处理的原因
- 标记待办事项

```kotlin
fun processUserData(user: User) {
    // 过滤掉未激活的用户
    if (!user.isActive) return
    
    // TODO: 添加用户行为统计
    
    // FIXME: 这里可能存在并发问题
    updateUserCache(user)
    
    // 注意：这里必须在主线程执行
    withContext(Dispatchers.Main) {
        updateUI(user)
    }
}
```

### 4.5 注释规范

```kotlin
// ✅ 正确
// 单行注释，斜杠后有空格

/*
 * 多行注释
 * 每行开头有星号
 */

/**
 * KDoc注释
 * 用于类、方法、属性
 */

// ❌ 错误
//单行注释，斜杠后没有空格

/* 多行注释
不规范的格式 */
```

## 5. Kotlin 最佳实践

### 5.1 空安全

- 优先使用非空类型
- 合理使用 `?.`、`?:`、`!!`
- 避免滥用 `!!`

```kotlin
// ✅ 正确
val userName: String = user?.name ?: "未知用户"

user?.let {
    processUser(it)
}

// 使用 requireNotNull 替代 !!
val userId = user?.id ?: error("User ID cannot be null")

// ❌ 错误
val userName = user!!.name  // 可能抛出 NPE
val userId = user?.id!!     // 滥用 !!
```

### 5.2 类型推断

- 简单类型可以省略类型声明
- 复杂类型明确声明
- 公开 API 必须声明类型

```kotlin
// ✅ 正确
val count = 10  // 类型推断为 Int
val name = "张三"  // 类型推断为 String
val userList: List<User> = repository.getUserList()  // 复杂类型明确声明

// 公开 API 明确类型
fun getUserById(id: Long): User

// ❌ 错误
val userList = repository.getUserList()  // 公开 API 应明确类型
```

### 5.3 数据类

- 使用 data class 表示数据模型
- 合理使用默认参数
- 使用 copy() 创建副本

```kotlin
// ✅ 正确
data class User(
    val id: Long,
    val name: String,
    val email: String? = null,
    val age: Int = 0
)

val updatedUser = user.copy(name = "新名字")

// ❌ 错误
class User(
    val id: Long,
    val name: String
) {
    // 手动实现 equals、hashCode、toString
}
```

### 5.4 扩展函数

- 优先使用扩展函数而非工具类
- 扩展函数放在独立的文件中
- 命名清晰，避免冲突

```kotlin
// ✅ 正确 - ContextExt.kt
fun Context.toast(message: String, duration: Int = Toast.LENGTH_SHORT) {
    Toast.makeText(this, message, duration).show()
}

fun Context.dp2px(dp: Float): Int {
    return (dp * resources.displayMetrics.density).toInt()
}

// 使用
context.toast("操作成功")

// ❌ 错误 - 使用工具类
object ToastUtil {
    fun show(context: Context, message: String) {
        Toast.makeText(context, message, Toast.LENGTH_SHORT).show()
    }
}
```

### 5.5 作用域函数

合理使用 `let`、`run`、`with`、`apply`、`also`

```kotlin
// let - 非空判断和转换
user?.let {
    println("User: ${it.name}")
}

// run - 对象配置和计算结果
val result = user.run {
    println("Processing user: $name")
    age * 2
}

// with - 对象多个操作
with(binding) {
    tvTitle.text = "标题"
    tvContent.text = "内容"
}

// apply - 对象配置
val user = User().apply {
    name = "张三"
    age = 25
}

// also - 附加操作
val user = createUser().also {
    println("Created user: ${it.name}")
}
```

### 5.6 集合操作

- 使用 Kotlin 集合操作符
- 避免不必要的中间集合
- 使用序列处理大数据

```kotlin
// ✅ 正确
val activeUsers = userList
    .filter { it.isActive }
    .map { it.name }
    .sortedBy { it }

// 大数据使用序列
val result = userList.asSequence()
    .filter { it.age > 18 }
    .map { it.name }
    .take(10)
    .toList()

// ❌ 错误
val activeUsers = mutableListOf<String>()
for (user in userList) {
    if (user.isActive) {
        activeUsers.add(user.name)
    }
}
activeUsers.sort()
```

### 5.7 协程使用

- 使用结构化并发
- 正确处理异常
- 避免阻塞主线程

```kotlin
// ✅ 正确
viewModelScope.launch {
    try {
        _userState.value = UiState.Loading
        val user = withContext(Dispatchers.IO) {
            repository.getUser(userId)
        }
        _userState.value = UiState.Success(user)
    } catch (e: Exception) {
        _userState.value = UiState.Error(-1, e.message ?: "未知错误")
    }
}

// 使用 Flow
repository.getUserFlow(userId)
    .flowOn(Dispatchers.IO)
    .catch { e ->
        emit(Result.Error(-1, e.message ?: "未知错误"))
    }
    .collect { result ->
        // 处理结果
    }

// ❌ 错误
GlobalScope.launch {  // 不要使用 GlobalScope
    val user = repository.getUser(userId)  // 可能阻塞主线程
}
```

### 5.8 when 表达式

- 优先使用 when 而非 if-else 链
- 使用 sealed class 确保完整性
- 复杂条件提取为变量

```kotlin
// ✅ 正确
when (state) {
    is UiState.Idle -> {
        // 空闲状态
    }
    is UiState.Loading -> {
        showLoading()
    }
    is UiState.Success -> {
        hideLoading()
        showData(state.data)
    }
    is UiState.Error -> {
        hideLoading()
        showError(state.message)
    }
}

// ❌ 错误
if (state is UiState.Idle) {
    // ...
} else if (state is UiState.Loading) {
    // ...
} else if (state is UiState.Success) {
    // ...
} else if (state is UiState.Error) {
    // ...
}
```

## 6. Android 最佳实践

### 6.1 Activity/Fragment

- 使用 ViewBinding
- 继承基类
- 生命周期方法按顺序排列

```kotlin
@AndroidEntryPoint
class UserActivity : BaseVMActivity<ActivityUserBinding, UserViewModel>() {

    override val viewModel: UserViewModel by viewModels()

    override fun createBinding(): ActivityUserBinding {
        return ActivityUserBinding.inflate(layoutInflater)
    }

    override fun initView() {
        binding.toolbar.setNavigationOnClickListener {
            finish()
        }
        
        binding.btnLoad.setOnClickListener {
            viewModel.loadUser(userId)
        }
    }

    override fun observeData() {
        super.observeData()
        
        viewModel.userState.collectOnMain(this) { state ->
            when (state) {
                is UiState.Loading -> showLoading()
                is UiState.Success -> {
                    hideLoading()
                    updateUI(state.data)
                }
                is UiState.Error -> {
                    hideLoading()
                    toast(state.message)
                }
                else -> {}
            }
        }
    }

    private fun updateUI(user: User) {
        binding.tvUserName.text = user.name
        binding.tvUserEmail.text = user.email
    }
}
```

### 6.2 ViewModel

- 使用 StateFlow 管理状态
- 不持有 Context 引用
- 使用 viewModelScope

```kotlin
@HiltViewModel
class UserViewModel @Inject constructor(
    private val repository: UserRepository
) : BaseViewModel() {

    private val _userState = MutableStateFlow<UiState<User>>(UiState.Idle)
    val userState: StateFlow<UiState<User>> = _userState.asStateFlow()

    fun loadUser(userId: Long) {
        viewModelScope.launch {
            _userState.value = UiState.Loading
            
            when (val result = repository.getUser(userId)) {
                is Result.Success -> {
                    _userState.value = UiState.Success(result.data)
                }
                is Result.Error -> {
                    _userState.value = UiState.Error(result.code, result.message)
                }
            }
        }
    }
}
```

### 6.3 RecyclerView Adapter

- 使用 ViewBinding
- 使用 DiffUtil
- 避免在 onBindViewHolder 中创建对象

```kotlin
class UserListAdapter : BaseAdapter<User, UserListAdapter.ViewHolder>() {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val binding = ItemUserBinding.inflate(
            LayoutInflater.from(parent.context),
            parent,
            false
        )
        return ViewHolder(binding)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.bind(getItem(position))
    }

    inner class ViewHolder(
        private val binding: ItemUserBinding
    ) : RecyclerView.ViewHolder(binding.root) {

        fun bind(user: User) {
            binding.tvUserName.text = user.name
            binding.tvUserEmail.text = user.email
            
            binding.root.setOnClickListener {
                onItemClick?.invoke(user)
            }
        }
    }

    companion object {
        val DIFF_CALLBACK = object : DiffUtil.ItemCallback<User>() {
            override fun areItemsTheSame(oldItem: User, newItem: User): Boolean {
                return oldItem.id == newItem.id
            }

            override fun areContentsTheSame(oldItem: User, newItem: User): Boolean {
                return oldItem == newItem
            }
        }
    }
}
```

### 6.4 资源使用

- 字符串、颜色、尺寸等使用资源文件
- 避免硬编码
- 使用主题和样式

```kotlin
// ✅ 正确
binding.tvTitle.text = getString(R.string.login_title)
binding.tvTitle.setTextColor(getColor(R.color.text_primary))
binding.tvTitle.textSize = resources.getDimension(R.dimen.text_size_large)

// ❌ 错误
binding.tvTitle.text = "登录"
binding.tvTitle.setTextColor(0xFF000000.toInt())
binding.tvTitle.textSize = 18f
```

### 6.5 依赖注入

- 使用 Hilt 进行依赖注入
- 构造函数注入优于字段注入
- 合理使用作用域

```kotlin
// ✅ 正确
@HiltViewModel
class UserViewModel @Inject constructor(
    private val repository: UserRepository
) : BaseViewModel()

@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    
    @Provides
    @Singleton
    fun provideOkHttpClient(): OkHttpClient {
        return OkHttpClient.Builder()
            .addInterceptor(HeaderInterceptor())
            .build()
    }
}

// ❌ 错误
class UserViewModel : BaseViewModel() {
    @Inject
    lateinit var repository: UserRepository  // 字段注入
}
```


## 7. 禁止事项

### 7.1 严格禁止

以下行为严格禁止，违反将导致代码审查不通过：

#### 7.1.1 硬编码

```kotlin
// ❌ 禁止硬编码字符串
binding.tvTitle.text = "登录"

// ✅ 使用资源文件
binding.tvTitle.text = getString(R.string.login_title)

// ❌ 禁止硬编码颜色
view.setBackgroundColor(0xFF6200EE.toInt())

// ✅ 使用颜色资源
view.setBackgroundColor(getColor(R.color.primary))

// ❌ 禁止硬编码尺寸
textView.textSize = 16f

// ✅ 使用尺寸资源
textView.textSize = resources.getDimension(R.dimen.text_size_normal)

// ❌ 禁止硬编码 URL
const val API_URL = "https://api.example.com"

// ✅ 使用 BuildConfig 或配置文件
const val API_URL = BuildConfig.API_URL
```

#### 7.1.2 内存泄漏

```kotlin
// ❌ 禁止在 ViewModel 中持有 Context
class UserViewModel(
    private val context: Context  // 会导致内存泄漏
) : ViewModel()

// ✅ 使用 Application Context 或传递必要的数据
class UserViewModel @Inject constructor(
    @ApplicationContext private val context: Context  // 使用 Application Context
) : ViewModel()

// ❌ 禁止在静态变量中持有 Activity 引用
companion object {
    var activity: Activity? = null  // 会导致内存泄漏
}

// ❌ 禁止使用非静态内部类持有外部引用
class MainActivity : AppCompatActivity() {
    inner class MyHandler : Handler() {  // 会导致内存泄漏
        // ...
    }
}

// ✅ 使用静态内部类 + 弱引用
class MainActivity : AppCompatActivity() {
    class MyHandler(activity: MainActivity) : Handler() {
        private val weakReference = WeakReference(activity)
        // ...
    }
}
```

#### 7.1.3 主线程阻塞

```kotlin
// ❌ 禁止在主线程进行网络请求
fun loadData() {
    val response = api.getUser(userId)  // 阻塞主线程
}

// ✅ 使用协程
fun loadData() {
    viewModelScope.launch {
        val response = withContext(Dispatchers.IO) {
            api.getUser(userId)
        }
    }
}

// ❌ 禁止在主线程进行数据库操作
fun saveUser(user: User) {
    userDao.insert(user)  // 阻塞主线程
}

// ✅ 使用协程
suspend fun saveUser(user: User) {
    withContext(Dispatchers.IO) {
        userDao.insert(user)
    }
}

// ❌ 禁止在主线程进行文件操作
fun readFile(): String {
    return File("path").readText()  // 阻塞主线程
}

// ✅ 使用协程
suspend fun readFile(): String {
    return withContext(Dispatchers.IO) {
        File("path").readText()
    }
}
```

#### 7.1.4 不安全的操作

```kotlin
// ❌ 禁止滥用 !!
val userName = user!!.name  // 可能抛出 NPE

// ✅ 使用安全调用
val userName = user?.name ?: "未知"

// ❌ 禁止捕获所有异常
try {
    // ...
} catch (e: Exception) {
    // 吞掉所有异常
}

// ✅ 捕获具体异常并处理
try {
    // ...
} catch (e: IOException) {
    Log.e(TAG, "IO error", e)
    showError("网络错误")
} catch (e: JsonParseException) {
    Log.e(TAG, "Parse error", e)
    showError("数据解析错误")
}

// ❌ 禁止使用 System.out.println
System.out.println("Debug info")

// ✅ 使用 Log 或日志框架
Log.d(TAG, "Debug info")

// ❌ 禁止明文存储敏感信息
val password = "123456"
sharedPreferences.edit().putString("password", password).apply()

// ✅ 加密存储
val encryptedPassword = encrypt(password)
sharedPreferences.edit().putString("password", encryptedPassword).apply()
```

### 7.2 不推荐使用

以下行为不推荐使用，应该寻找更好的替代方案：

#### 7.2.1 过时的 API

```kotlin
// ❌ 不推荐使用 AsyncTask（已废弃）
class MyAsyncTask : AsyncTask<Void, Void, String>()

// ✅ 使用协程
viewModelScope.launch {
    val result = withContext(Dispatchers.IO) {
        // 后台任务
    }
}

// ❌ 不推荐使用 Handler.postDelayed
handler.postDelayed({ doSomething() }, 1000)

// ✅ 使用协程
viewModelScope.launch {
    delay(1000)
    doSomething()
}

// ❌ 不推荐使用 findViewById
val textView = findViewById<TextView>(R.id.tv_title)

// ✅ 使用 ViewBinding
binding.tvTitle.text = "标题"
```

#### 7.2.2 不良实践

```kotlin
// ❌ 不推荐使用魔法数字
if (userType == 1) {
    // ...
}

// ✅ 使用常量或枚举
const val USER_TYPE_ADMIN = 1
if (userType == USER_TYPE_ADMIN) {
    // ...
}

// ❌ 不推荐过长的方法
fun processData() {
    // 100+ 行代码
}

// ✅ 拆分为多个小方法
fun processData() {
    validateData()
    transformData()
    saveData()
}

// ❌ 不推荐过深的嵌套
if (condition1) {
    if (condition2) {
        if (condition3) {
            if (condition4) {
                // ...
            }
        }
    }
}

// ✅ 提前返回
if (!condition1) return
if (!condition2) return
if (!condition3) return
if (!condition4) return
// ...

// ❌ 不推荐使用可变集合作为返回值
fun getUserList(): MutableList<User> {
    return userList
}

// ✅ 返回不可变集合
fun getUserList(): List<User> {
    return userList.toList()
}
```

#### 7.2.3 性能问题

```kotlin
// ❌ 不推荐在循环中创建对象
for (i in 0 until 1000) {
    val paint = Paint()  // 每次循环创建新对象
    canvas.drawCircle(x, y, radius, paint)
}

// ✅ 复用对象
val paint = Paint()
for (i in 0 until 1000) {
    canvas.drawCircle(x, y, radius, paint)
}

// ❌ 不推荐频繁的字符串拼接
var result = ""
for (item in list) {
    result += item.toString()  // 每次创建新字符串
}

// ✅ 使用 StringBuilder
val result = StringBuilder()
for (item in list) {
    result.append(item.toString())
}

// ❌ 不推荐在 onDraw 中创建对象
override fun onDraw(canvas: Canvas) {
    val paint = Paint()  // 每次绘制创建新对象
    canvas.drawCircle(x, y, radius, paint)
}

// ✅ 在构造函数中创建
private val paint = Paint()

override fun onDraw(canvas: Canvas) {
    canvas.drawCircle(x, y, radius, paint)
}
```

## 8. 代码审查清单

在提交代码前，请确保通过以下检查：

### 8.1 基础检查

- [ ] 代码编译通过，无错误
- [ ] 代码格式化（使用 Android Studio 格式化）
- [ ] 移除所有未使用的导入
- [ ] 移除所有调试代码和注释
- [ ] 移除所有 TODO 和 FIXME（或创建对应的任务）

### 8.2 命名检查

- [ ] 类名使用 PascalCase
- [ ] 方法名使用 camelCase
- [ ] 变量名使用 camelCase
- [ ] 常量名使用 UPPER_SNAKE_CASE
- [ ] 资源文件使用 snake_case
- [ ] 命名清晰，表达准确

### 8.3 注释检查

- [ ] 公开类有 KDoc 注释
- [ ] 公开方法有 KDoc 注释
- [ ] 复杂逻辑有行内注释
- [ ] 注释内容准确，无误导

### 8.4 代码质量检查

- [ ] 无硬编码字符串、颜色、尺寸
- [ ] 无内存泄漏风险
- [ ] 无主线程阻塞
- [ ] 正确处理异常
- [ ] 合理使用空安全
- [ ] 避免过长的方法（< 50 行）
- [ ] 避免过深的嵌套（< 4 层）

### 8.5 架构检查

- [ ] 遵循 MVVM 架构
- [ ] 正确的模块依赖
- [ ] 使用依赖注入
- [ ] 数据流向正确
- [ ] 职责分离清晰

### 8.6 性能检查

- [ ] 避免在循环中创建对象
- [ ] 避免频繁的字符串拼接
- [ ] 合理使用缓存
- [ ] 图片资源优化
- [ ] 避免过度绘制

### 8.7 安全检查

- [ ] 敏感信息加密存储
- [ ] 网络请求使用 HTTPS
- [ ] 输入验证
- [ ] 权限检查
- [ ] 混淆配置正确

## 9. 工具配置

### 9.1 Android Studio 配置

#### 代码格式化

1. 打开 Settings → Editor → Code Style → Kotlin
2. 选择 "Set from..." → "Kotlin style guide"
3. 设置行长度为 120

#### 自动导入优化

1. 打开 Settings → Editor → General → Auto Import
2. 勾选 "Optimize imports on the fly"
3. 勾选 "Add unambiguous imports on the fly"

#### 保存时格式化

1. 安装 "Save Actions" 插件
2. 配置保存时自动格式化代码

### 9.2 Lint 配置

在 `build.gradle.kts` 中配置：

```kotlin
android {
    lint {
        abortOnError = true
        checkAllWarnings = true
        warningsAsErrors = false
        
        disable += listOf(
            "UnusedResources",
            "ContentDescription"
        )
    }
}
```

### 9.3 Detekt 配置

添加 Detekt 进行静态代码分析：

```kotlin
// build.gradle.kts
plugins {
    id("io.gitlab.arturbosch.detekt") version "1.23.0"
}

detekt {
    config = files("config/detekt/detekt.yml")
    buildUponDefaultConfig = true
}
```

## 10. 参考资源

### 10.1 官方文档

- [Kotlin 编码规范](https://kotlinlang.org/docs/coding-conventions.html)
- [Android 开发者指南](https://developer.android.com/guide)
- [Material Design 指南](https://material.io/design)

### 10.2 推荐阅读

- 《Effective Kotlin》
- 《Android 开发艺术探索》
- 《重构：改善既有代码的设计》

### 10.3 在线工具

- [Kotlin Playground](https://play.kotlinlang.org/)
- [Android API 参考](https://developer.android.com/reference)
- [Material Design 组件](https://material.io/components)

---

**本规范持续更新，最后更新时间：2025-10-09**

